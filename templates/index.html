<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RizzRoom - Modern Chat</title>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #10b981;
      --accent: #f59e0b;
      --danger: #ef4444;
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --text-muted: #64748b;
      --border: #334155;
      --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.25);
      --radius: 12px;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
    }

    /* Main Layout */
    .app {
      display: flex;
      height: 100vh;
      position: relative;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      transition: transform 0.3s ease;
    }

    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 20px;
      font-weight: 700;
      color: var(--primary);
    }

    .logo-icon {
      width: 32px;
      height: 32px;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .rooms-section {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 12px;
      letter-spacing: 0.5px;
    }

    .room-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .room-item {
      padding: 12px 16px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 500;
    }

    .room-item:hover {
      background: var(--bg-tertiary);
    }

    .room-item.active {
      background: var(--primary);
      color: white;
    }

    .room-icon {
      font-size: 18px;
    }

    .user-section {
      padding: 20px;
      border-top: 1px solid var(--border);
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .user-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 16px;
    }

    .user-details h4 {
      font-size: 14px;
      font-weight: 600;
    }

    .user-details p {
      font-size: 12px;
      color: var(--text-muted);
    }

    .action-buttons {
      display: flex;
      gap: 8px;
    }

    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: var(--radius);
      font-weight: 500;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-dark);
      transform: translateY(-1px);
    }

    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-admin {
      background: var(--accent);
      color: white;
    }

    /* Chat Area */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
    }

    .chat-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--bg-secondary);
    }

    .chat-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .chat-title h2 {
      font-size: 18px;
      font-weight: 600;
    }

    .online-count {
      background: var(--secondary);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
    }

    .chat-actions {
      display: flex;
      gap: 8px;
    }

    .icon-btn {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 8px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .icon-btn:hover {
      background: var(--border);
      color: var(--text-primary);
    }

    .icon-btn.broadcasting {
      background: var(--danger);
      color: white;
      animation: pulse 2s infinite;
    }

    .icon-btn.broadcasting:hover {
      background: var(--danger);
      transform: scale(1.05);
    }

    .broadcast-status {
      display: flex;
      align-items: center;
      gap: 12px;
      background: var(--bg-tertiary);
      padding: 8px 12px;
      border-radius: var(--radius);
      border: 1px solid var(--danger);
    }

    .status-text {
      font-size: 12px;
      font-weight: 500;
      color: var(--danger);
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }

    /* Messages */
    .messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .message {
      display: flex;
      gap: 12px;
      animation: slideIn 0.3s ease;
    }

    .message.own {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      flex-shrink: 0;
    }

    .message-content {
      max-width: 70%;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .message-author {
      font-weight: 600;
      color: var(--text-secondary);
    }

    .message-bubble {
      background: var(--bg-secondary);
      padding: 12px 16px;
      border-radius: 16px;
      border-top-left-radius: 4px;
      word-wrap: break-word;
      line-height: 1.4;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .message-bubble:hover {
      background: var(--bg-tertiary);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }
    
    .message-bubble::after {
      content: 'Click to react';
      position: absolute;
      bottom: -20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-primary);
      color: var(--text-muted);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      white-space: nowrap;
    }
    
    .message-bubble:hover::after {
      opacity: 1;
    }

    .message.own .message-bubble {
      background: var(--primary);
      border-top-left-radius: 16px;
      border-top-right-radius: 4px;
    }

    .message.own .message-bubble:hover {
      background: var(--primary-dark);
    }

    .message-reactions {
      display: flex;
      gap: 4px;
      margin-top: 4px;
    }

    .reaction {
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .reaction:hover {
      background: var(--border);
    }

    /* Message Input */
    .message-input-container {
      padding: 20px 24px;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .message-input-wrapper {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .input-group {
      flex: 1;
      position: relative;
    }

    .message-input {
      width: 100%;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 24px;
      padding: 12px 50px 12px 20px;
      color: var(--text-primary);
      font-size: 14px;
      resize: none;
      outline: none;
      transition: all 0.2s ease;
      max-height: 120px;
      min-height: 44px;
    }

    .message-input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .input-actions {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      gap: 4px;
    }

    .input-btn {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .input-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .send-btn {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 50%;
      background: var(--primary);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .send-btn:hover {
      background: var(--primary-dark);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--bg-tertiary);
      color: var(--text-muted);
      cursor: not-allowed;
      transform: none;
    }

    /* Emoji Picker */
    .emoji-picker {
      position: absolute;
      bottom: 80px;
      right: 24px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      display: none;
      grid-template-columns: repeat(8, 1fr);
      gap: 8px;
      box-shadow: var(--shadow);
      z-index: 1000;
    }

    .emoji-picker.show {
      display: grid;
    }

    .emoji-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: transparent;
      font-size: 18px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .emoji-btn:hover {
      background: var(--bg-tertiary);
      transform: scale(1.1);
    }

    /* Reaction Picker */
    .reaction-picker {
      position: fixed;
      background: var(--bg-secondary);
      border: 2px solid var(--primary);
      border-radius: var(--radius);
      padding: 8px;
      display: none;
      grid-template-columns: repeat(6, 1fr);
      gap: 4px;
      box-shadow: var(--shadow);
      z-index: 9999;
      min-width: 200px;
      pointer-events: auto;
    }

    .reaction-picker.show {
      display: grid;
      animation: fadeIn 0.2s ease;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .reaction-picker .emoji-btn {
      width: 28px;
      height: 28px;
      font-size: 16px;
      border-radius: 4px;
    }

    .reaction-picker .emoji-btn:hover {
      background: var(--bg-tertiary);
      transform: scale(1.2);
    }

    /* Auth Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: var(--radius);
      padding: 32px;
      width: 100%;
      max-width: 400px;
      margin: 20px;
      box-shadow: var(--shadow);
    }

    .modal h2 {
      margin-bottom: 24px;
      text-align: center;
      font-size: 24px;
      font-weight: 700;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .form-input {
      width: 100%;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      color: var(--text-primary);
      font-size: 14px;
      outline: none;
      transition: all 0.2s ease;
    }

    .form-input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }

    .form-error {
      color: var(--danger);
      font-size: 12px;
      margin-top: 8px;
    }

    .form-footer {
      margin-top: 24px;
      text-align: center;
    }

    .form-footer button {
      width: 100%;
      padding: 12px;
      margin-bottom: 16px;
    }

    .form-link {
      color: var(--primary);
      cursor: pointer;
      font-size: 14px;
    }

    .form-link:hover {
      text-decoration: underline;
    }

    /* Admin Panel */
    .admin-panel {
      background: var(--bg-secondary);
      border-radius: var(--radius);
      padding: 24px;
      width: 100%;
      max-width: 600px;
      margin: 20px;
      box-shadow: var(--shadow);
      max-height: 80vh;
      overflow-y: auto;
    }

    .admin-section {
      margin-bottom: 32px;
    }

    .admin-section h3 {
      margin-bottom: 16px;
      color: var(--primary);
      font-size: 18px;
    }

    .admin-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: var(--bg-primary);
      border-radius: var(--radius);
      margin-bottom: 8px;
    }

    .admin-item-info {
      flex: 1;
    }

    .admin-item-actions {
      display: flex;
      gap: 8px;
    }

    .btn-small {
      padding: 4px 8px;
      font-size: 11px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        height: 100vh;
        z-index: 1000;
        transform: translateX(-100%);
      }

      .sidebar.open {
        transform: translateX(0);
      }

      .chat-container {
        width: 100%;
      }

      .mobile-header {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 16px 20px;
        background: var(--bg-secondary);
        border-bottom: 1px solid var(--border);
      }

      .menu-btn {
        width: 36px;
        height: 36px;
        border: none;
        background: transparent;
        color: var(--text-primary);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .chat-header {
        display: none;
      }

      .messages-container {
        padding: 16px;
      }

      .message-input-container {
        padding: 16px;
      }

      .emoji-picker {
        right: 16px;
        bottom: 80px;
      }

      .reaction-picker {
        max-width: 200px;
      }
    }

    /* Animations */
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--border);
    }

    /* Utilities */
    .hidden {
      display: none !important;
    }

    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <div class="logo">
          <div class="logo-icon">üí¨</div>
          <span>RizzRoom</span>
        </div>
      </div>
      
      <div class="rooms-section">
        <div class="section-title">Channels</div>
        <div class="room-list">
          <div class="room-item active" data-room="main">
            <span class="room-icon">#</span>
            <span>main</span>
          </div>
          <!-- <div class="room-item" data-room="memes">
            <span class="room-icon">#</span>
            <span>memes</span>
          </div>
          <div class="room-item" data-room="wins">
            <span class="room-icon">#</span>
            <span>wins</span>
          </div> -->
        </div>
      </div>

      <div class="user-section">
        <div class="user-info">
          <div class="user-avatar" id="userAvatar">U</div>
          <div class="user-details">
            <h4 id="userName">User</h4>
            <p>Online</p>
          </div>
        </div>
        <div class="action-buttons">
          <button class="btn btn-admin hidden" id="adminBtn">‚ö° Admin</button>
          <button class="btn btn-secondary" id="logoutBtn">Logout</button>
        </div>
      </div>
    </aside>

    <!-- Chat Container -->
    <main class="chat-container">
      <!-- Mobile Header -->
      <div class="mobile-header hidden" id="mobileHeader">
        <button class="menu-btn" id="menuBtn">‚ò∞</button>
        <h2>#main</h2>
      </div>

      <!-- Chat Header -->
      <div class="chat-header" id="chatHeader">
        <div class="chat-title">
          <h2>#main</h2>
          <span class="online-count" id="onlineCount">0 online</span>
        </div>
        <div class="chat-actions">
          <button class="icon-btn" id="broadcastBtn" title="Start Broadcasting" data-broadcasting="false">üé§</button>
          <div class="broadcast-status hidden" id="broadcastStatus">
            <span class="status-text">üé§ Broadcasting...</span>
            <button class="btn btn-secondary btn-small" id="stopBroadcastBtn">Stop</button>
          </div>
          <button class="icon-btn" id="testAudioBtn" title="Test Audio">üîä</button>
          <button class="icon-btn" title="Search">üîç</button>
          <button class="icon-btn" title="Settings">‚öôÔ∏è</button>
        </div>
      </div>

      <!-- Messages -->
      <div class="messages-container" id="messagesContainer">
        <!-- Messages will be inserted here -->
      </div>

      <!-- Message Input -->
      <div class="message-input-container">
        <div class="message-input-wrapper">
          <div class="input-group">
            <textarea 
              class="message-input" 
              id="messageInput" 
              placeholder="Type a message..."
              rows="1"
            ></textarea>
            <div class="input-actions">
              <button class="input-btn" id="emojiBtn" title="Emoji">üòä</button>
              <label class="input-btn" for="fileInput" title="Attach file">üìé</label>
              <input type="file" id="fileInput" class="hidden">
            </div>
          </div>
          <button class="send-btn" id="sendBtn" title="Send message">
            <span>‚û§</span>
          </button>
        </div>
      </div>
    </main>
  </div>

  <!-- Emoji Picker -->
  <div class="emoji-picker" id="emojiPicker">
    <!-- Emojis will be inserted here -->
  </div>

  <!-- Reaction Picker -->
  <div class="reaction-picker" id="reactionPicker">
    <!-- Reaction emojis will be inserted here -->
  </div>

  <!-- Auth Modal -->
  <div class="modal-overlay hidden" id="authModal">
    <div class="modal">
      <h2 id="authTitle">Welcome to RizzRoom</h2>
      <form id="authForm">
        <div class="form-group">
          <label class="form-label">Username</label>
          <input type="text" class="form-input" id="authUsername" required>
        </div>
        <div class="form-group">
          <label class="form-label">Password</label>
          <input type="password" class="form-input" id="authPassword" required>
        </div>
        <div class="form-group hidden" id="emailGroup">
          <label class="form-label">Email</label>
          <input type="email" class="form-input" id="authEmail">
        </div>
        <div class="form-error hidden" id="authError"></div>
        <div class="form-footer">
          <button type="submit" class="btn btn-primary" id="authSubmit">Sign In</button>
          <div class="form-link" id="authToggle">Don't have an account? Sign up</div>
        </div>
      </form>
    </div>
  </div>

  <!-- Admin Panel Modal -->
  <div class="modal-overlay hidden" id="adminModal">
    <div class="admin-panel">
      <h2>Admin Panel</h2>
      
      <div class="admin-section">
        <h3>Pending Users</h3>
        <div id="pendingUsers">
          <!-- Pending users will be inserted here -->
        </div>
      </div>

      <div class="admin-section">
        <h3>Recent Messages</h3>
        <div id="recentMessages">
          <!-- Recent messages will be inserted here -->
        </div>
      </div>

      <div class="form-footer">
        <button class="btn btn-secondary" id="closeAdminBtn">Close</button>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const API_BASE = '';
    const SOCKET_URL = window.location.origin;
    const MAX_BYTES = 5 * 1024 * 1024;

    // State
    let token = localStorage.getItem('rr_token') || null;
    let user = JSON.parse(localStorage.getItem('rr_user') || 'null');
    let socket = null;
    let isLoginMode = true;
    let currentReactionMessageId = null;
    
    // Audio broadcasting state
    let isBroadcasting = false;
    let localStream = null;
    let peerConnections = new Map();
    let onlineUsers = new Set();
    let currentBroadcaster = null;

    // DOM Elements
    const authModal = document.getElementById('authModal');
    const authForm = document.getElementById('authForm');
    const authTitle = document.getElementById('authTitle');
    const authUsername = document.getElementById('authUsername');
    const authPassword = document.getElementById('authPassword');
    const authEmail = document.getElementById('authEmail');
    const emailGroup = document.getElementById('emailGroup');
    const authError = document.getElementById('authError');
    const authSubmit = document.getElementById('authSubmit');
    const authToggle = document.getElementById('authToggle');
    
    const sidebar = document.getElementById('sidebar');
    const menuBtn = document.getElementById('menuBtn');
    const mobileHeader = document.getElementById('mobileHeader');
    const chatHeader = document.getElementById('chatHeader');
    
    const userName = document.getElementById('userName');
    const userAvatar = document.getElementById('userAvatar');
    const adminBtn = document.getElementById('adminBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    
    const messagesContainer = document.getElementById('messagesContainer');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const fileInput = document.getElementById('fileInput');
    const emojiBtn = document.getElementById('emojiBtn');
    const emojiPicker = document.getElementById('emojiPicker');
    const reactionPicker = document.getElementById('reactionPicker');
    
    const adminModal = document.getElementById('adminModal');
    const pendingUsers = document.getElementById('pendingUsers');
    const recentMessages = document.getElementById('recentMessages');
    const closeAdminBtn = document.getElementById('closeAdminBtn');
    
    // Audio broadcasting elements
    const broadcastBtn = document.getElementById('broadcastBtn');
    const broadcastStatus = document.getElementById('broadcastStatus');
    const stopBroadcastBtn = document.getElementById('stopBroadcastBtn');
    const testAudioBtn = document.getElementById('testAudioBtn');
    const onlineCount = document.getElementById('onlineCount');

    // Emojis
    const EMOJIS = ['üòä','üòé','üî•','üíÄ','üíñ','üòÇ','ü•≥','üò≠','üëç','üëÄ','üòè','‚ú®','ü§ù','üí¨','üéâ','‚ù§Ô∏è','üòç','ü§î','üò¢','üò°','üôÑ','üò¥','ü§ó','ü§Ø','ü•∫','üòà','üëè','üôå','üíØ','üî•'];
    const REACTION_EMOJIS = ['üòä', 'üòÇ', '‚ù§Ô∏è', 'üëç', 'üòÆ', 'üò¢', 'üò°', 'üî•', 'üíØ', 'üéâ', 'üëè', 'ü§î'];

    // Initialize emoji pickers
    function initEmojiPickers() {
      emojiPicker.innerHTML = EMOJIS.map(emoji => 
        `<button class="emoji-btn" type="button" data-emoji="${emoji}">${emoji}</button>`
      ).join('');
      
      reactionPicker.innerHTML = REACTION_EMOJIS.map(emoji =>
        `<button class="emoji-btn" type="button" data-emoji="${emoji}">${emoji}</button>`
      ).join('');
      
      // Ensure reaction picker is properly positioned
      reactionPicker.style.position = 'fixed';
      reactionPicker.style.zIndex = '9999';
    }

    // Auth functions
    async function login(username, password) {
      const response = await fetch(`${API_BASE}/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
      });
      
      if (!response.ok) {
        const error = await response.json().catch(() => ({ msg: 'Login failed' }));
        throw new Error(error.msg || 'Login failed');
      }
      
      return response.json();
    }

        async function register(username, password, email) {
      const response = await fetch(`${API_BASE}/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password, email })
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ msg: 'Registration failed' }));
        throw new Error(error.msg || 'Registration failed');
      }

      return response.json();
    }



        function setSession(accessToken, userData) {
      token = accessToken;
      user = userData;
      localStorage.setItem('rr_token', token);
      localStorage.setItem('rr_user', JSON.stringify(user));

      userName.textContent = user.username;
      userAvatar.textContent = user.username.charAt(0).toUpperCase();

      if (user.role === 'admin') {
        adminBtn.classList.remove('hidden');
      }
    }

    function clearSession() {
      token = null;
      user = null;
      localStorage.removeItem('rr_token');
      localStorage.removeItem('rr_user');
      adminBtn.classList.add('hidden');
      if (socket) socket.disconnect();
    }

    function showAuthModal(show = true) {
      authModal.classList.toggle('hidden', !show);
    }

    function toggleAuthMode() {
      isLoginMode = !isLoginMode;
      
      if (isLoginMode) {
        authTitle.textContent = 'Welcome Back';
        authSubmit.textContent = 'Sign In';
        authToggle.textContent = "Don't have an account? Sign up";
        emailGroup.classList.add('hidden');
      } else {
        authTitle.textContent = 'Join RizzRoom';
        authSubmit.textContent = 'Sign Up';
        authToggle.textContent = 'Already have an account? Sign in';
        emailGroup.classList.remove('hidden');
      }
      
      authError.classList.add('hidden');
    }

    function showError(message) {
      authError.textContent = message;
      authError.classList.remove('hidden');
    }

    // WebRTC configuration
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ]
    };

    // Socket functions
    function connectSocket() {
      console.log('Connecting to Socket.IO server...');
      
      socket = io(SOCKET_URL, { 
        transports: ['websocket', 'polling'],
        timeout: 20000,
        forceNew: true
      });
      
      socket.on('connect', () => {
        console.log('Connected to server with ID:', socket.id);
        socket.emit('join', { username: user?.username || 'anon' });
        socket.emit('audio:join', { 
          user_id: user?.id, 
          username: user?.username || 'Anonymous' 
        });
      });
      
      socket.on('disconnect', (reason) => {
        console.log('Disconnected from server:', reason);
      });
      
      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        addSystemMessage('‚ùå Connection error. Please refresh the page.');
      });
      
      socket.on('system', data => addSystemMessage(data.msg));
      socket.on('message:new', payload => addMessage(payload));
      socket.on('message:delete', ({ id }) => markMessageDeleted(id));
      socket.on('reaction:new', data => addReaction(data.message_id, data.emoji, data.user_id));
      socket.on('reaction:remove', data => removeReaction(data.message_id, data.emoji, data.user_id));
      
      // Audio broadcasting events
      socket.on('audio:user_joined', handleUserJoined);
      socket.on('audio:user_left', handleUserLeft);
      socket.on('audio:broadcast_started', handleBroadcastStarted);
      socket.on('audio:broadcast_stopped', handleBroadcastStopped);
      socket.on('audio:offer', handleAudioOffer);
      socket.on('audio:answer', handleAudioAnswer);
      socket.on('audio:ice_candidate', handleIceCandidate);
      
      console.log('Socket.IO event listeners configured');
    }

    // Audio broadcasting functions
    async function startBroadcasting() {
      try {
        console.log('Starting broadcast...');
        
        // Request microphone permission
        localStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }, 
          video: false 
        });
        
        console.log('Microphone access granted, stream:', localStream);
        
        isBroadcasting = true;
        currentBroadcaster = user.id;
        
        // Update UI
        broadcastBtn.classList.add('broadcasting');
        broadcastBtn.setAttribute('data-broadcasting', 'true');
        broadcastBtn.title = 'Stop Broadcasting';
        broadcastStatus.classList.remove('hidden');
        
        // Notify server
        socket.emit('audio:start_broadcast', {
          user_id: user.id,
          username: user.username
        });
        
        console.log('Broadcast started, creating peer connections for users:', Array.from(onlineUsers));
        
        // Create peer connections for existing users
        onlineUsers.forEach(userId => {
          if (userId !== user.id) {
            createPeerConnection(userId);
          }
        });
        
        addSystemMessage(`üé§ ${user.username} started broadcasting`);
        
      } catch (error) {
        console.error('Failed to start broadcasting:', error);
        if (error.name === 'NotAllowedError') {
          addSystemMessage('‚ùå Microphone access denied. Please allow microphone access to broadcast.');
        } else {
          addSystemMessage('‚ùå Failed to start broadcasting. Please check your microphone.');
        }
      }
    }

    async function stopBroadcasting() {
      if (!isBroadcasting) return;
      
      try {
        // Stop local stream
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
        
        // Close all peer connections
        peerConnections.forEach((pc, userId) => {
          pc.close();
        });
        peerConnections.clear();
        
        isBroadcasting = false;
        currentBroadcaster = null;
        
        // Update UI
        broadcastBtn.classList.remove('broadcasting');
        broadcastBtn.setAttribute('data-broadcasting', 'false');
        broadcastBtn.title = 'Start Broadcasting';
        broadcastStatus.classList.add('hidden');
        
        // Notify server
        socket.emit('audio:stop_broadcast', {
          user_id: user.id,
          username: user.username
        });
        
        addSystemMessage(`üîá ${user.username} stopped broadcasting`);
        
      } catch (error) {
        console.error('Failed to stop broadcasting:', error);
      }
    }

    function createPeerConnection(userId) {
      console.log(`Creating peer connection for user ${userId}`);
      
      const pc = new RTCPeerConnection(rtcConfig);
      peerConnections.set(userId, pc);
      
      // Add local stream tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          console.log(`Adding track to peer connection:`, track);
          console.log('Track kind:', track.kind);
          console.log('Track enabled:', track.enabled);
          console.log('Track muted:', track.muted);
          
          // Ensure track is enabled and not muted
          track.enabled = true;
          
          const sender = pc.addTrack(track, localStream);
          console.log('Track sender created:', sender);
        });
      }
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`Sending ICE candidate to user ${userId}:`, event.candidate);
          socket.emit('audio:ice_candidate', {
            candidate: event.candidate,
            from_id: user.id,
            to_id: userId
          });
        }
      };
      
      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        console.log(`Peer connection state for user ${userId}:`, pc.connectionState);
        if (pc.connectionState === 'connected') {
          console.log(`‚úÖ Peer connection established with user ${userId}`);
        }
      };
      
      // Handle ICE connection state changes
      pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state for user ${userId}:`, pc.iceConnectionState);
      };
      
      // Create and send offer
      pc.createOffer()
        .then(offer => {
          console.log(`Created offer for user ${userId}:`, offer);
          console.log('Offer SDP:', offer.sdp);
          return pc.setLocalDescription(offer);
        })
        .then(() => {
          console.log(`Sending offer to user ${userId}`);
          socket.emit('audio:offer', {
            offer: pc.localDescription,
            broadcaster_id: user.id,
            username: user.username
          });
        })
        .catch(error => {
          console.error(`Failed to create offer for user ${userId}:`, error);
        });
      
      return pc;
    }

    function handleUserJoined(data) {
      onlineUsers.add(data.user_id);
      updateOnlineCount();
      
      if (isBroadcasting && data.user_id !== user.id) {
        createPeerConnection(data.user_id);
      }
    }

    function handleUserLeft(data) {
      onlineUsers.delete(data.user_id);
      updateOnlineCount();
      
      // Close peer connection if exists
      const pc = peerConnections.get(data.user_id);
      if (pc) {
        pc.close();
        peerConnections.delete(data.user_id);
      }
    }

    function handleBroadcastStarted(data) {
      if (data.broadcaster_id === user.id) return; // Don't handle our own broadcast
      
      console.log(`Broadcast started by ${data.username} (ID: ${data.broadcaster_id})`);
      currentBroadcaster = data.broadcaster_id;
      addSystemMessage(`üé§ ${data.username} started broadcasting`);
      
      // Create peer connection to listen to broadcaster
      const pc = new RTCPeerConnection(rtcConfig);
      peerConnections.set(data.broadcaster_id, pc);
      
      // Handle incoming audio
      pc.ontrack = (event) => {
        console.log(`Received audio track from ${data.username}:`, event.streams[0]);
        console.log('Track details:', event.track);
        console.log('Stream details:', event.streams[0]);
        
        // Create audio element and ensure it plays
        const audio = new Audio();
        audio.srcObject = event.streams[0];
        audio.volume = 1.0;
        audio.autoplay = true;
        audio.controls = true; // Add controls for debugging
        
        // Store audio element for later reference
        audio.id = `audio-${data.broadcaster_id}`;
        document.body.appendChild(audio);
        
        // Ensure audio plays
        const playPromise = audio.play();
        if (playPromise !== undefined) {
          playPromise
            .then(() => {
              console.log(`‚úÖ Audio playing from ${data.username}`);
              addSystemMessage(`üéß Now listening to ${data.username}`);
            })
            .catch(error => {
              console.error(`‚ùå Failed to play audio from ${data.username}:`, error);
              addSystemMessage(`‚ùå Audio playback failed: ${error.message}`);
            });
        }
      };
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`Sending ICE candidate to broadcaster ${data.broadcaster_id}`);
          socket.emit('audio:ice_candidate', {
            candidate: event.candidate,
            from_id: user.id,
            to_id: data.broadcaster_id
          });
        }
      };
      
      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        console.log(`Peer connection state with broadcaster ${data.username}:`, pc.connectionState);
        if (pc.connectionState === 'connected') {
          addSystemMessage(`üîó Connected to ${data.username}'s audio stream`);
        } else if (pc.connectionState === 'failed') {
          addSystemMessage(`‚ùå Failed to connect to ${data.username}'s audio stream`);
        }
      };
      
      // Handle ICE connection state changes
      pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state with ${data.username}:`, pc.iceConnectionState);
      };
    }

    function handleBroadcastStopped(data) {
      if (data.broadcaster_id === user.id) return; // Don't handle our own broadcast
      
      currentBroadcaster = null;
      addSystemMessage(`üîá ${data.username} stopped broadcasting`);
      
      // Close peer connection
      const pc = peerConnections.get(data.broadcaster_id);
      if (pc) {
        pc.close();
        peerConnections.delete(data.broadcaster_id);
      }
    }

    function handleAudioOffer(data) {
      if (data.broadcaster_id === user.id) return; // Don't handle our own offer
      
      console.log(`Received audio offer from ${data.username} (ID: ${data.broadcaster_id})`);
      console.log('Offer data:', data.offer);
      
      const pc = peerConnections.get(data.broadcaster_id);
      if (!pc) {
        console.error(`No peer connection found for broadcaster ${data.broadcaster_id}`);
        return;
      }
      
      console.log('Setting remote description...');
      pc.setRemoteDescription(new RTCSessionDescription(data.offer))
        .then(() => {
          console.log('Remote description set, creating answer...');
          return pc.createAnswer();
        })
        .then(answer => {
          console.log('Answer created:', answer);
          console.log('Answer SDP:', answer.sdp);
          return pc.setLocalDescription(answer);
        })
        .then(() => {
          console.log('Local description set, sending answer...');
          socket.emit('audio:answer', {
            answer: pc.localDescription,
            listener_id: user.id,
            broadcaster_id: data.broadcaster_id
          });
          console.log('Answer sent successfully');
        })
        .catch(error => {
          console.error('Failed to handle offer:', error);
          addSystemMessage(`‚ùå Failed to establish audio connection: ${error.message}`);
        });
    }

    function handleAudioAnswer(data) {
      if (data.listener_id === user.id) return; // Don't handle our own answer
      
      const pc = peerConnections.get(data.listener_id);
      if (!pc) return;
      
      pc.setRemoteDescription(new RTCSessionDescription(data.answer))
        .catch(error => {
          console.error('Failed to handle answer:', error);
        });
    }

    function handleIceCandidate(data) {
      if (data.from_id === user.id) return; // Don't handle our own candidates
      
      const pc = peerConnections.get(data.from_id);
      if (!pc) return;
      
      pc.addIceCandidate(new RTCIceCandidate(data.candidate))
        .catch(error => {
          console.error('Failed to add ICE candidate:', error);
        });
    }

    function updateOnlineCount() {
      onlineCount.textContent = `${onlineUsers.size} online`;
    }
    
    // Debug function to check audio state
    function debugAudioState() {
      console.log('=== AUDIO DEBUG INFO ===');
      console.log('Is broadcasting:', isBroadcasting);
      console.log('Local stream:', localStream);
      console.log('Current broadcaster:', currentBroadcaster);
      console.log('Peer connections:', peerConnections.size);
      console.log('Online users:', Array.from(onlineUsers));
      
      if (localStream) {
        console.log('Local stream tracks:', localStream.getTracks());
        localStream.getTracks().forEach((track, index) => {
          console.log(`Track ${index}:`, {
            kind: track.kind,
            enabled: track.enabled,
            muted: track.muted,
            readyState: track.readyState
          });
        });
      }
      
      peerConnections.forEach((pc, userId) => {
        console.log(`Peer connection ${userId}:`, {
          connectionState: pc.connectionState,
          iceConnectionState: pc.iceConnectionState,
          signalingState: pc.signalingState
        });
      });
      
      console.log('=== END DEBUG INFO ===');
    }
    
    // Add debug button to chat actions
    const debugBtn = document.createElement('button');
    debugBtn.className = 'icon-btn';
    debugBtn.innerHTML = 'üêõ';
    debugBtn.title = 'Debug Audio State';
    debugBtn.onclick = debugAudioState;
    document.querySelector('.chat-actions').appendChild(debugBtn);

    // Message functions
    function createMessageElement(message) {
      const isOwn = user && message.user_id === user.id;
      const messageEl = document.createElement('div');
      messageEl.className = `message ${isOwn ? 'own' : ''}`;
      messageEl.id = `message-${message.id}`;
      
      // Get username or fallback to User ID
      const username = message.username || `User ${message.user_id}`;
      const avatarText = message.username ? message.username.charAt(0).toUpperCase() : String(message.user_id).charAt(0);
      
      // Format timestamp
      const timestamp = message.created_at ? 
        new Date(message.created_at).toLocaleTimeString() : 
        new Date().toLocaleTimeString();
      
      messageEl.innerHTML = `
        <div class="message-avatar">${avatarText}</div>
        <div class="message-content">
          <div class="message-header">
            <span class="message-author">${escapeHtml(username)}</span>
            <span class="message-time">${timestamp}</span>
          </div>
          <div class="message-bubble" data-message-id="${message.id}" title="Click to react">${escapeHtml(message.content)}</div>
          <div class="message-reactions" id="reactions-${message.id}"></div>
        </div>
      `;
      
      return messageEl;
    }

    function addMessage(message) {
      const messageEl = createMessageElement(message);
      messagesContainer.appendChild(messageEl);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function addSystemMessage(text) {
      const messageEl = document.createElement('div');
      messageEl.className = 'system-message';
      messageEl.innerHTML = `<div style="text-align: center; color: var(--text-muted); font-size: 12px; margin: 16px 0;">${escapeHtml(text)}</div>`;
      messagesContainer.appendChild(messageEl);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    function markMessageDeleted(messageId) {
      const messageEl = document.getElementById(`message-${messageId}`);
      if (messageEl) {
        const bubble = messageEl.querySelector('.message-bubble');
        bubble.innerHTML = '<em style="opacity: 0.6;">Message deleted</em>';
      }
    }

    function addReaction(messageId, emoji, userId) {
      const reactionsEl = document.getElementById(`reactions-${messageId}`);
      if (reactionsEl) {
        const reactionEl = document.createElement('span');
        reactionEl.className = 'reaction';
        reactionEl.textContent = emoji;
        reactionsEl.appendChild(reactionEl);
      }
    }

    function removeReaction(messageId, emoji, userId) {
      // Simple implementation - could be more sophisticated
      const reactionsEl = document.getElementById(`reactions-${messageId}`);
      if (reactionsEl) {
        const reactions = reactionsEl.querySelectorAll('.reaction');
        reactions.forEach(reaction => {
          if (reaction.textContent === emoji) {
            reaction.remove();
            return;
          }
        });
      }
    }

        async function loadMessages() {
      try {
        const response = await fetch(`${API_BASE}/rooms/main/messages`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });

        if (!response.ok) {
          if (response.status === 401) {
            // Token expired, redirect to login
            clearSession();
            showAuthModal(true);
          }
          return;
        }

        const messages = await response.json();
        messagesContainer.innerHTML = '';
        messages.forEach(message => addMessage(message));
      } catch (error) {
        console.error('Failed to load messages:', error);
      }
    }

    async function sendMessage() {
      const content = messageInput.value.trim();
      const file = fileInput.files[0];
      
      if (!content && !file) return;
      
      try {
        // Send message
        const messageContent = content || 'üìé Shared a file';
        const response = await fetch(`${API_BASE}/rooms/main/messages`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ content: messageContent })
        });
        
        if (!response.ok) throw new Error('Failed to send message');
        
        const message = await response.json();
        
        // Handle file upload if present
        if (file) {
          await handleFileUpload(file, message.id);
        }
        
        messageInput.value = '';
        fileInput.value = '';
        adjustTextareaHeight();
        
      } catch (error) {
        console.error('Failed to send message:', error);
        showError('Failed to send message');
      }
    }

    async function handleFileUpload(file, messageId) {
      try {
        // Get presigned URL
        const presignResponse = await fetch(`${API_BASE}/uploads/presign`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            filename: file.name,
            mime_type: file.type || 'application/octet-stream',
            size_bytes: file.size
          })
        });
        
        if (!presignResponse.ok) throw new Error('Failed to get upload URL');
        
        const presignData = await presignResponse.json();
        
        // Upload to S3
        const formData = new FormData();
        Object.entries(presignData.fields).forEach(([key, value]) => {
          formData.append(key, value);
        });
        formData.append('file', file);
        
        const uploadResponse = await fetch(presignData.url, {
          method: 'POST',
          body: formData
        });
        
        if (!uploadResponse.ok) throw new Error('Failed to upload file');
        
        // Link attachment
        await fetch(`${API_BASE}/messages/${messageId}/attachments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            s3_key: presignData.s3_key,
            mime_type: file.type,
            size_bytes: file.size
          })
        });
        
      } catch (error) {
        console.error('File upload failed:', error);
      }
    }

    // Reaction functions
    function showReactionPicker(messageId, event) {
      currentReactionMessageId = messageId;
      
      // Get viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Get picker dimensions
      const pickerWidth = 200; // min-width from CSS
      const pickerHeight = 80; // approximate height
      
      // Calculate position to keep picker within viewport
      let left = event.clientX;
      let top = event.clientY - 50;
      
      // Adjust horizontal position if picker would go off-screen
      if (left + pickerWidth > viewportWidth) {
        left = viewportWidth - pickerWidth - 10;
      }
      if (left < 10) {
        left = 10;
      }
      
      // Adjust vertical position if picker would go off-screen
      if (top < 10) {
        top = event.clientY + 20;
      }
      if (top + pickerHeight > viewportHeight) {
        top = viewportHeight - pickerHeight - 10;
      }
      
      reactionPicker.style.left = left + 'px';
      reactionPicker.style.top = top + 'px';
      reactionPicker.classList.add('show');
      
      console.log('Reaction picker shown at:', { left, top, messageId });
    }

    function hideReactionPicker() {
      reactionPicker.classList.remove('show');
      currentReactionMessageId = null;
    }

    async function addReactionToMessage(messageId, emoji) {
      try {
        await fetch(`${API_BASE}/messages/${messageId}/reactions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ emoji })
        });
      } catch (error) {
        console.error('Failed to add reaction:', error);
      }
    }

    // Admin functions
    async function loadPendingUsers() {
      try {
        const response = await fetch(`${API_BASE}/admin/users/pending`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) return;
        
        const users = await response.json();
        pendingUsers.innerHTML = users.map(user => `
          <div class="admin-item">
            <div class="admin-item-info">
              <strong>${user.username}</strong><br>
              <small>${user.email}</small>
            </div>
            <div class="admin-item-actions">
              <button class="btn btn-primary btn-small" onclick="approveUser(${user.id})">Approve</button>
              <button class="btn btn-secondary btn-small" onclick="suspendUser(${user.id})">Reject</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Failed to load pending users:', error);
      }
    }

    async function loadRecentMessages() {
      try {
        const response = await fetch(`${API_BASE}/rooms/main/messages`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!response.ok) return;
        
        const messages = await response.json();
        recentMessages.innerHTML = messages.slice(-10).map(message => `
          <div class="admin-item">
            <div class="admin-item-info">
              <strong>User ${message.user_id}</strong><br>
              <small>${message.content}</small>
            </div>
            <div class="admin-item-actions">
              <button class="btn btn-secondary btn-small" onclick="deleteMessage(${message.id})">Delete</button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Failed to load recent messages:', error);
      }
    }

    async function approveUser(userId) {
      try {
        await fetch(`${API_BASE}/admin/users/${userId}/approve`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        loadPendingUsers();
      } catch (error) {
        console.error('Failed to approve user:', error);
      }
    }

    async function suspendUser(userId) {
      try {
        await fetch(`${API_BASE}/admin/users/${userId}/suspend`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        loadPendingUsers();
      } catch (error) {
        console.error('Failed to suspend user:', error);
      }
    }

    async function deleteMessage(messageId) {
      try {
        await fetch(`${API_BASE}/admin/messages/${messageId}`, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` }
        });
        loadRecentMessages();
      } catch (error) {
        console.error('Failed to delete message:', error);
      }
    }

    // Utility functions
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function adjustTextareaHeight() {
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 120) + 'px';
    }

    function isMobile() {
      return window.innerWidth <= 768;
    }

    function updateMobileLayout() {
      if (isMobile()) {
        mobileHeader.classList.remove('hidden');
        chatHeader.classList.add('hidden');
      } else {
        mobileHeader.classList.add('hidden');
        chatHeader.classList.remove('hidden');
        sidebar.classList.remove('open');
      }
    }

    // Event listeners
    authForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const username = authUsername.value.trim();
      const password = authPassword.value;
      const email = authEmail.value.trim();
      
      if (!username || !password) {
        showError('Please fill in all fields');
        return;
      }
      
      try {
        authSubmit.classList.add('loading');
        
        if (isLoginMode) {
          const result = await login(username, password);
          setSession(result.access_token, result.user);
          showAuthModal(false);
          connectSocket();
          loadMessages();
        } else {
          if (!email) {
            showError('Email is required for registration');
            return;
          }
          await register(username, password, email);
          showError('Registration successful! Please wait for admin approval.');
          setTimeout(() => {
            toggleAuthMode();
            authForm.reset();
          }, 2000);
        }
      } catch (error) {
        showError(error.message);
      } finally {
        authSubmit.classList.remove('loading');
      }
    });

    authToggle.addEventListener('click', toggleAuthMode);

    logoutBtn.addEventListener('click', () => {
      clearSession();
      showAuthModal(true);
    });

    adminBtn.addEventListener('click', async () => {
      adminModal.classList.remove('hidden');
      await loadPendingUsers();
      await loadRecentMessages();
    });

    closeAdminBtn.addEventListener('click', () => {
      adminModal.classList.add('hidden');
    });

    menuBtn.addEventListener('click', () => {
      sidebar.classList.toggle('open');
    });

    messageInput.addEventListener('input', adjustTextareaHeight);

    messageInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    sendBtn.addEventListener('click', sendMessage);

    // Broadcast button event listeners
    broadcastBtn.addEventListener('click', () => {
      if (isBroadcasting) {
        stopBroadcasting();
      } else {
        startBroadcasting();
      }
    });

    stopBroadcastBtn.addEventListener('click', stopBroadcasting);
    
    // Test audio button
    testAudioBtn.addEventListener('click', async () => {
      try {
        console.log('Testing audio...');
        const testStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }, 
          video: false 
        });
        
        console.log('Test stream obtained:', testStream);
        console.log('Audio tracks:', testStream.getAudioTracks());
        
        const audio = new Audio();
        audio.srcObject = testStream;
        audio.volume = 0.5; // Lower volume for test
        audio.controls = true; // Add controls for debugging
        
        // Add to DOM for debugging
        audio.id = 'test-audio';
        document.body.appendChild(audio);
        
        audio.play().then(() => {
          console.log('‚úÖ Audio test successful - microphone is working');
          addSystemMessage('‚úÖ Audio test successful - microphone is working');
          
          // Stop the test stream after 5 seconds
          setTimeout(() => {
            testStream.getTracks().forEach(track => track.stop());
            if (audio.parentNode) {
              audio.parentNode.removeChild(audio);
            }
            addSystemMessage('üîá Audio test completed');
          }, 5000);
        }).catch(error => {
          console.error('‚ùå Audio test failed:', error);
          addSystemMessage('‚ùå Audio test failed - check browser console');
        });
        
      } catch (error) {
        console.error('Failed to test audio:', error);
        addSystemMessage('‚ùå Audio test failed - microphone access denied');
      }
    });

    emojiBtn.addEventListener('click', () => {
      emojiPicker.classList.toggle('show');
    });

    emojiPicker.addEventListener('click', (e) => {
      if (e.target.classList.contains('emoji-btn')) {
        messageInput.value += e.target.dataset.emoji;
        emojiPicker.classList.remove('show');
        messageInput.focus();
        adjustTextareaHeight();
      }
    });

    // Reaction picker click handler
    reactionPicker.addEventListener('click', (e) => {
      if (e.target.classList.contains('emoji-btn') && currentReactionMessageId) {
        const emoji = e.target.dataset.emoji;
        addReactionToMessage(currentReactionMessageId, emoji);
        hideReactionPicker();
      }
    });

    // Click outside to close pickers
    document.addEventListener('click', (e) => {
      if (!emojiBtn.contains(e.target) && !emojiPicker.contains(e.target)) {
        emojiPicker.classList.remove('show');
      }
      if (!reactionPicker.contains(e.target)) {
        hideReactionPicker();
      }
    });

    // Click outside to close sidebar on mobile
    document.addEventListener('click', (e) => {
      if (isMobile() && sidebar.classList.contains('open') && 
          !sidebar.contains(e.target) && !menuBtn.contains(e.target)) {
        sidebar.classList.remove('open');
      }
    });

    // Also close reaction picker when pressing Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideReactionPicker();
        emojiPicker.classList.remove('show');
      }
    });

    // Message reactions - show reaction picker when clicked
    messagesContainer.addEventListener('click', (e) => {
      if (e.target.closest('.message-bubble')) {
        const messageEl = e.target.closest('.message');
        const messageId = messageEl.id.replace('message-', '');
        if (messageId) {
          showReactionPicker(messageId, e);
        }
      }
    });

    // Window resize handler
    window.addEventListener('resize', updateMobileLayout);

    // Initialize app
    function init() {
      initEmojiPickers();
      updateMobileLayout();
      
      if (token && user) {
        userName.textContent = user.username;
        userAvatar.textContent = user.username.charAt(0).toUpperCase();
        
        if (user.role === 'admin') {
          adminBtn.classList.remove('hidden');
        }
        
        // Add current user to online users
        onlineUsers.add(user.id);
        updateOnlineCount();
        
        showAuthModal(false);
        connectSocket();
        loadMessages();
      } else {
        showAuthModal(true);
      }
    }

    // Start the app
    init();
  </script>
</body>
</html>